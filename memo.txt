haskell relational record

Project Euler #601


まず、問題の定義通りに実装してみる。

---
streak :: Int -> Int
streak n
  | n `mod` 2 == 0 = 1
  | otherwise = (snd . head . filter check $ zip [(n+2)..] [3..]) - 1
  where check (a, b) = a `mod` b /= 0

getP :: Int -> Int -> Int
getP s n = length . filter (==s) . map streak $ [2..n]

solve :: Int
solve = sum . map (\i -> getP i (4^i)) $ [1..31]
---

ここで、
streak(1)=無限
streak(2m)=1 (m=1,2,3,...)
を使用している。

実行すると、予想通り時間がかかる計算であり、全く進む気配がない。
---
*Main> :l src/PJ601.hs 
[1 of 1] Compiling Main             ( src/PJ601.hs, interpreted )
Ok, modules loaded: Main.
*Main> solve 
^CInterrupted.
---

定義通りに実装すると、solve内で
map streak [2..4^i]
が実行されるが、要素の前半部分
map streak [2..4^(i-1)]
はすでに計算済みのはずであり、solveを呼び出すたびに実行するのは非効率である。
ならば最初に
map streak [2..4^31]
を計算しておけば早くなりそうだが、streakの呼ばれる回数は、全部でおおよそ
\Sigma_{i=1}^31 4^i = (4^32-1)/(4-1) = ?????回、
最初にmap streak [2..4^31]を計算しておくとしても4^31回程度でおよそ3/4程度にしかならない。

そこで、現実的な時間で計算するために別のアプローチを取ろう。
「例示は理解の試金石」の言葉通り、まずはstreak関数の振る舞いを観察してみる。
---
*Main> map streak [2..1000]
[1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,7,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,8,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,6,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1,2,1,3,1,2,1,2,1,4,1,2,1]
*Main>
---

結果を観察してみると、いくつかのことに気がつく。
・1,2,3,4が、規則的に現れている。
・6,7,8も、ポツポツ現れている
・5は現れていない

ここで、リスト上で値nが現れる位置を特定するため、以下の関数を定義しよう。
getpos :: Int -> [Int]
getpos n = map fst . filter (\x -> snd x == n) . zip [1..] $ map streak [2..(4^31)]

それぞれの値に対して、初めて現れる位置は、以下の通り。
---
*Main> head $ getpos 1
1
*Main> head $ getpos 2
2
*Main> head $ getpos 3
6
*Main> head $ getpos 4
12
*Main> head $ getpos 5
^CInterrupted.
*Main> head $ getpos 6
60
*Main> head $ getpos 7
420
*Main> head $ getpos 8
840
*Main> head $ getpos 9
^CInterrupted.
*Main> head $ getpos 10
2520
*Main> head $ getpos 11
^CInterrupted.
*Main> head $ getpos 12
27720
*Main> head $ getpos 13
^CInterrupted.
*Main> head $ getpos 14
^CInterrupted.
*Main> head $ getpos 15
360360
*Main> head $ getpos 16
720720
*Main>
---


この結果より、以下が予想できる（予想1）。
・1からnまでの最小公倍数をf(n)とすると、値nが現れる最初の位置はf(n)に等しい。
・ただし、f(n)=f(n+1)ならば、nはstreak関数の結果とはならない。


なお、Prelude.lcmを用いて以下の通りf(n)を定義すると、
---
f :: Int -> Int
f 1 = 1
f n = lcm n (f (n-1))
---
---
*Main> map (pair (id, f)) [1..32]
[(1,1),(2,2),(3,6),(4,12),(5,60),(6,60),(7,420),(8,840),(9,2520),(10,2520),(11,27720),(12,27720),(13,360360),(14,360360),(15,360360),(16,720720),(17,12252240),(18,12252240),(19,232792560),(20,232792560),(21,232792560),(22,232792560),(23,5354228880),(24,5354228880),(25,26771144400),(26,26771144400),(27,80313433200),(28,80313433200),(29,2329089562800),(30,2329089562800),(31,72201776446800),(32,144403552893600)]
*Main>
---
となっており、確かに(head $ getpos n)は予想通りの振る舞いをしているように見える。


それぞれの値が最初に現れる位置を予想できたので、
次はそれぞれの値がどのような規則で出現するか、見てみることにしよう。



basen :: Int -> Int
basen n = fromMaybe 0 . lookup n . map (pair (id, f)) $ [1..32]

